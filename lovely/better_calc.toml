[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

## Calculation Contexts
# Destroying calculation on scoring_hand cards
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''if destroyed then '''
match_indent = true
position = "before"
payload = '''
local destroyed_calc = eval_card(G.hand.cards[1], {destroying_card = G.hand.cards[1], full_hand = G.hand.cards})
if next(destroyed_calc) == 'destroyed' then destroyed = destroyed_calc end
'''




## G.FUNCS.evaluate_play()

 # Handle repetitions from playing cards
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
local reps = {1}

--From Red seal
local eval = eval_card(scoring_hand[i], {repetition_only = true,cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, repetition = true})
if next(eval) then
    for h = 1, eval.seals.repetitions do
        reps[#reps+1] = eval
    end
end
--From jokers
for j=1, #G.jokers.cards do
    --calculate the joker effects
    local eval = eval_card(G.jokers.cards[j], {cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, other_card = scoring_hand[i], repetition = true})
    if next(eval) and eval.jokers then 
        for h = 1, eval.jokers.repetitions do
            reps[#reps+1] = eval
        end
    end
end
'''
position = 'at'
match_indent = true
payload = '''
local reps = SMODS.calculate_repetitions(scoring_hand[i], G.play, scoring_hand, text, poker_hands)
'''
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''
--Check for hand doubling

--From Red seal
local eval = eval_card(G.hand.cards[i], {repetition_only = true,cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, repetition = true, card_effects = effects})
if next(eval) and (next(effects[1]) or #effects > 1) then 
    for h  = 1, eval.seals.repetitions do
        reps[#reps+1] = eval
    end
end

--From Joker
for j=1, #G.jokers.cards do
    --calculate the joker effects
    local eval = eval_card(G.jokers.cards[j], {cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, other_card = G.hand.cards[i], repetition = true, card_effects = effects})
    if next(eval) then 
        for h  = 1, eval.jokers.repetitions do
            reps[#reps+1] = eval
        end
    end
end
'''
position = 'at'
match_indent = true
payload = '''
reps = SMODS.calculate_repetitions(G.hand.cards[i], G.hand, scoring_hand, text, poker_hands, effects)
'''

# Handle retrigger messages
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''card_eval_status_text((reps[j].jokers or reps[j].seals).card, 'jokers', nil, nil, nil, (reps[j].jokers or reps[j].seals))'''
position = 'at'
match_indent = true
payload = '''
local _, eff = next(reps[j])
card_eval_status_text(eff.card, 'jokers', nil, nil, nil, eff)'''

## eval_card()
# handle debuffed playing cards
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
function eval_card(card, context)
'''
position = 'after'
match_indent = true
payload = '''
    if card.ability.set ~= 'Joker' and card.debuff then return {} end
'''

# built in config values
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if context.cardarea == G.play then
    local chips = card:get_chip_bonus()
    if chips > 0 then 
        ret.chips = chips
    end

    local mult = card:get_chip_mult()
    if mult > 0 then 
        ret.mult = mult
    end

    local x_mult = card:get_chip_x_mult(context)
    if x_mult > 0 then 
        ret.x_mult = x_mult
    end

    local p_dollars = card:get_p_dollars()
    if p_dollars > 0 then 
        ret.p_dollars = p_dollars
    end
'''
match_indent = true
position = "at"
payload = """
if context.cardarea == G.play and context.main_scoring then
    ret.playing_card = {}
    local chips = card:get_chip_bonus()
    if chips > 0 then 
        ret.playing_card.chips = chips
    end

    local mult = card:get_chip_mult()
    if mult > 0 then 
        ret.playing_card.mult = mult
    end

    local x_mult = card:get_chip_x_mult(context)
    if x_mult > 0 then 
        ret.playing_card.x_mult = x_mult
    end

    local p_dollars = card:get_p_dollars()
    if p_dollars > 0 then 
        ret.playing_card.p_dollars = p_dollars
    end
"""
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if context.cardarea == G.hand then
    local h_mult = card:get_chip_h_mult()
    if h_mult > 0 then 
        ret.h_mult = h_mult
    end

    local h_x_mult = card:get_chip_h_x_mult()
    if h_x_mult > 0 then 
        ret.x_mult = h_x_mult
    end
'''
match_indent = true
position = "at"
payload = """
if context.cardarea == G.hand and context.main_scoring then
    ret.playing_card = {}
    local h_mult = card:get_chip_h_mult()
    if h_mult > 0 then 
        ret.playing_card.h_mult = h_mult
    end

    local h_x_mult = card:get_chip_h_x_mult()
    if h_x_mult > 0 then 
        ret.playing_card.x_mult = h_x_mult
    end
"""

# Add context.main_scoring to G.play and G.hand
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "local effects = {eval_card(scoring_hand[i], {cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, poker_hand = text})}"
match_indent = true
position = "at"
payload = "local effects = {eval_card(scoring_hand[i], {main_scoring = true, cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, poker_hand = text})}"
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "local effects = {eval_card(G.hand.cards[i], {cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands})}"
match_indent = true
position = "at"
payload = "local effects = {eval_card(G.hand.cards[i], {main_scoring = true, cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands})}"


[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "local seals = card:calculate_seal(context)"
match_indent = true
position = "before"
payload = """
local enhancement = card:calculate_enhancement(context)
if enhancement then
    ret.enhancement = enhancement
end
local edition = card:calculate_edition(context)
if edition then
    ret.edition = edition
end
for k,v in pairs(SMODS.Stickers) do
    local sticker = card:calculate_sticker(context, k)
    if sticker then
        ret[v] = sticker
    end
end"""
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if context.cardarea == G.jokers or context.card == G.consumeables then"
match_indent = true
position = "before"
payload = """
local enhancement = card:calculate_enhancement(context)
if enhancement then
    ret.enhancement = enhancement
end
local edition = card:calculate_edition(context)
if edition then
    ret.edition = edition
end
local seals = not card.ability.extra_enhancement and card:calculate_seal(context)
if seals then
    ret.seals = seals
end"""
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if context.cardarea == G.jokers or context.card == G.consumeables then
    local jokers = nil
    if context.edition then
        jokers = card:get_edition(context)
    elseif context.other_joker then
        jokers = context.other_joker:calculate_joker(context)
    else
        jokers = card:calculate_joker(context)
    end
    if jokers then 
        ret.jokers = jokers
    end'''
match_indent = true
position = "at"
payload = """
if card.ability.set == 'Joker' or card.ability.consumeable then
    local jokers = nil
    if context.other_joker then
        jokers = context.other_joker:calculate_joker(context)
    else
        jokers = card:calculate_joker(context)
    end
    if jokers then 
        ret.jokers = jokers
    end
"""


[[patches]]
[patches.regex]
target = 'functions/common_events.lua'
position = 'after'
pattern = '( ){4}if context\.cardarea == G\.jokers or context\.card == G\.consumeables then(\n.*)*?\n( ){4}end\n'
payload = '''
    for k,v in pairs(SMODS.Stickers) do
        local sticker = card:calculate_sticker(context, k)
        if sticker then
            ret[v] = sticker
        end
    end
'''

# G.FUNCS.evaluate_play()
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''j = j +1'''
match_indent = true
position = "at"
payload = '''j = j + (effects.calculated and 1 or #reps)'''


[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
--calculate the card edition effects
if effects[ii].edition then
    hand_chips = mod_chips(hand_chips + (effects[ii].edition.chip_mod or 0))
    mult = mult + (effects[ii].edition.mult_mod or 0)
    mult = mod_mult(mult*(effects[ii].edition.x_mult_mod or 1))
    update_hand_text({delay = 0}, {
        chips = effects[ii].edition.chip_mod and hand_chips or nil,
        mult = (effects[ii].edition.mult_mod or effects[ii].edition.x_mult_mod) and mult or nil,
    })
    card_eval_status_text(scoring_hand[i], 'extra', nil, percent, nil, {
        message = (effects[ii].edition.chip_mod and localize{type='variable',key='a_chips',vars={effects[ii].edition.chip_mod}}) or
                (effects[ii].edition.mult_mod and localize{type='variable',key='a_mult',vars={effects[ii].edition.mult_mod}}) or
                (effects[ii].edition.x_mult_mod and localize{type='variable',key='a_xmult',vars={effects[ii].edition.x_mult_mod}}),
        chip_mod =  effects[ii].edition.chip_mod,
        mult_mod =  effects[ii].edition.mult_mod,
        x_mult_mod =  effects[ii].edition.x_mult_mod,
        colour = G.C.DARK_EDITION,
        edition = true})
end
'''
match_indent = true
position = "at"
payload = ''

## Remove base game calculations
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
--If chips added, do chip add event and add the chips to the total
if effects[ii].chips then 
    if effects[ii].card then juice_card(effects[ii].card) end
    hand_chips = mod_chips(hand_chips + effects[ii].chips)
    update_hand_text({delay = 0}, {chips = hand_chips})
    card_eval_status_text(scoring_hand[i], 'chips', effects[ii].chips, percent)
end

--If mult added, do mult add event and add the mult to the total
if effects[ii].mult then 
    if effects[ii].card then juice_card(effects[ii].card) end
    mult = mod_mult(mult + effects[ii].mult)
    update_hand_text({delay = 0}, {mult = mult})
    card_eval_status_text(scoring_hand[i], 'mult', effects[ii].mult, percent)
end

--If play dollars added, add dollars to total
if effects[ii].p_dollars then 
    if effects[ii].card then juice_card(effects[ii].card) end
    ease_dollars(effects[ii].p_dollars)
    card_eval_status_text(scoring_hand[i], 'dollars', effects[ii].p_dollars, percent)
end

--If dollars added, add dollars to total
if effects[ii].dollars then 
    if effects[ii].card then juice_card(effects[ii].card) end
    ease_dollars(effects[ii].dollars)
    card_eval_status_text(scoring_hand[i], 'dollars', effects[ii].dollars, percent)
end

--Any extra effects
if effects[ii].extra then 
    if effects[ii].card then juice_card(effects[ii].card) end
    local extras = {mult = false, hand_chips = false}
    if effects[ii].extra.mult_mod then mult =mod_mult( mult + effects[ii].extra.mult_mod);extras.mult = true end
    if effects[ii].extra.chip_mod then hand_chips = mod_chips(hand_chips + effects[ii].extra.chip_mod);extras.hand_chips = true end
    if effects[ii].extra.swap then 
        local old_mult = mult
        mult = mod_mult(hand_chips)
        hand_chips = mod_chips(old_mult)
        extras.hand_chips = true; extras.mult = true
    end
    if effects[ii].extra.func then effects[ii].extra.func() end
    update_hand_text({delay = 0}, {chips = extras.hand_chips and hand_chips, mult = extras.mult and mult})
    card_eval_status_text(scoring_hand[i], 'extra', nil, percent, nil, effects[ii].extra)
end

--If x_mult added, do mult add event and mult the mult to the total
if effects[ii].x_mult then 
    if effects[ii].card then juice_card(effects[ii].card) end
    mult = mod_mult(mult*effects[ii].x_mult)
    update_hand_text({delay = 0}, {mult = mult})
    card_eval_status_text(scoring_hand[i], 'x_mult', effects[ii].x_mult, percent)
end

'''
match_indent = true
position = "at"
payload = '''
-- Base game calculation removed
for key, effect in pairs(effects[ii]) do
    if type(effect) == 'table' then
        SMODS.calculate_effect(effect, scoring_hand[i], percent)
    end
end'''

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
--if this effect came from a joker
if effects[ii].card then
    mod_percent = true
    G.E_MANAGER:add_event(Event({
        trigger = 'immediate',
        func = (function() effects[ii].card:juice_up(0.7);return true end)
    }))
end

--If hold mult added, do hold mult add event and add the mult to the total

--If dollars added, add dollars to total
if effects[ii].dollars then 
    ease_dollars(effects[ii].dollars)
    card_eval_status_text(G.hand.cards[i], 'dollars', effects[ii].dollars, percent)
end

if effects[ii].h_mult then
    mod_percent = true
    mult = mod_mult(mult + effects[ii].h_mult)
    update_hand_text({delay = 0}, {mult = mult})
    card_eval_status_text(G.hand.cards[i], 'h_mult', effects[ii].h_mult, percent)
end

if effects[ii].x_mult then
    mod_percent = true
    mult = mod_mult(mult*effects[ii].x_mult)
    update_hand_text({delay = 0}, {mult = mult})
    card_eval_status_text(G.hand.cards[i], 'x_mult', effects[ii].x_mult, percent)
end

if effects[ii].message then
    mod_percent = true
    update_hand_text({delay = 0}, {mult = mult})
    card_eval_status_text(G.hand.cards[i], 'extra', nil, percent, nil, effects[ii])
end
'''
match_indent = true
position = "at"
payload = '''
-- Base game calculation removed 2
for key, effect in pairs(effects[ii]) do
    if type(effect) == 'table' then
        local calculated = SMODS.calculate_effect(effect, G.hand.cards[i], percent)
        if calculated then effects.calculated = true end
    end
end'''
# Joker Effects
# Edition effects
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
--calculate the joker edition effects
local edition_effects = eval_card(_card, {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, edition = true})
if edition_effects.jokers then
    edition_effects.jokers.edition = true
    if edition_effects.jokers.chip_mod then
        hand_chips = mod_chips(hand_chips + edition_effects.jokers.chip_mod)
        update_hand_text({delay = 0}, {chips = hand_chips})
        card_eval_status_text(_card, 'jokers', nil, percent, nil, {
            message = localize{type='variable',key='a_chips',vars={edition_effects.jokers.chip_mod}},
            chip_mod =  edition_effects.jokers.chip_mod,
            colour =  G.C.EDITION,
            edition = true})
    end
    if edition_effects.jokers.mult_mod then
        mult = mod_mult(mult + edition_effects.jokers.mult_mod)
        update_hand_text({delay = 0}, {mult = mult})
        card_eval_status_text(_card, 'jokers', nil, percent, nil, {
            message = localize{type='variable',key='a_mult',vars={edition_effects.jokers.mult_mod}},
            mult_mod =  edition_effects.jokers.mult_mod,
            colour = G.C.DARK_EDITION,
            edition = true})
    end
    percent = percent+percent_delta
end'''
match_indent = true
position = "at"
payload = '''
-- remove base game joker edition calc
local edition_eval = eval_card(_card, {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, edition = true})
for type, effect in pairs(edition_eval) do
    if type == 'edition' then SMODS.calculate_effect(effect, _card, 1, true, true) end
end'''
# Edition mult effects
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
if edition_effects.jokers then
    if edition_effects.jokers.x_mult_mod then
        mult = mod_mult(mult*edition_effects.jokers.x_mult_mod)
        update_hand_text({delay = 0}, {mult = mult})
        card_eval_status_text(_card, 'jokers', nil, percent, nil, {
            message = localize{type='variable',key='a_xmult',vars={edition_effects.jokers.x_mult_mod}},
            x_mult_mod =  edition_effects.jokers.x_mult_mod,
            colour =  G.C.EDITION,
            edition = true})
    end
    percent = percent+percent_delta
end'''
match_indent = true
position = "at"
payload = '''
-- calculate edition multipliers
for type, effect in pairs(edition_eval) do
    if type == 'edition' then SMODS.calculate_effect(effect, _card, 1, true, false) end
end'''
# Joker effects
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
--calculate the joker effects
local effects = eval_card(_card, {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, joker_main = true})
G.GAME.selected_back:trigger_effect({context = 'joker_main', joker =  _card, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands})

--Any Joker effects
if effects.jokers then 
    local extras = {mult = false, hand_chips = false}
    if effects.jokers.mult_mod then mult = mod_mult(mult + effects.jokers.mult_mod);extras.mult = true end
    if effects.jokers.chip_mod then hand_chips = mod_chips(hand_chips + effects.jokers.chip_mod);extras.hand_chips = true end
    if effects.jokers.Xmult_mod then mult = mod_mult(mult*effects.jokers.Xmult_mod);extras.mult = true  end
    update_hand_text({delay = 0}, {chips = extras.hand_chips and hand_chips, mult = extras.mult and mult})
    card_eval_status_text(_card, 'jokers', nil, percent, nil, effects.jokers)
    percent = percent+percent_delta
end'''
match_indent = true
position = "at"
payload = '''
-- Calculate context.joker_main
local effects = eval_card(_card, {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, joker_main = true})
for type, effect in pairs(effects) do
    if type ~= 'edition' then SMODS.calculate_effect(effect, _card, 1) end
end'''

## Fix other evaluations
# Discarding cards
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
if eval then
    if eval.remove then removed = true end
    card_eval_status_text(G.jokers.cards[j], 'jokers', nil, 1, nil, eval)
end'''
match_indent = true
position = "at"
payload = '''
for type, effect in pairs(eval) do
    if effect.remove then removed = true end
    SMODS.calculate_effect(effect, G.jokers.cards[j], 1)   
end'''

# context.before
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
for i=1, #G.jokers.cards do
    --calculate the joker effects
    local effects = eval_card(G.jokers.cards[i], {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, before = true})
    if effects.jokers then
        card_eval_status_text(G.jokers.cards[i], 'jokers', nil, percent, nil, effects.jokers)
        percent = percent + percent_delta
        if effects.jokers.level_up then
            level_up_hand(G.jokers.cards[i], text)
        end
    end
end'''
match_indent = true
position = "at"
payload = '''
-- context.before calculations
for i=1, #G.jokers.cards do
    --calculate the joker effects
    local effects = eval_card(G.jokers.cards[i], {cardarea = G.jokers, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, before = true})
    for type, effect in pairs(effects) do
        SMODS.calculate_effect(effect, G.jokers.cards[i], percent)
    end
end
for i=1, #scoring_hand do
    --calculate the played card effects
    local effects = eval_card(scoring_hand[i], {cardarea = G.play, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, before = true})
    for type, effect in pairs(effects) do
        SMODS.calculate_effect(effect, scoring_hand[i], percent)
    end
end
for i=1, #G.hand.cards do
    --calculate the held card effects
    local effects = eval_card(G.hand.cards[i], {cardarea = G.hand, full_hand = G.play.cards, scoring_hand = scoring_hand, scoring_name = text, poker_hands = poker_hands, before = true})
    for type, effect in pairs(effects) do
        SMODS.calculate_effect(effect, G.hand.cards[i], percent)
    end
end'''